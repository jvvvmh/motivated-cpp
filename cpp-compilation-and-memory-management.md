# Motivated C++

[TOC]

## C++编译与语言相关

### C++内存管理

ELF: Executable and Linkable Format

<img src="images\ELF.PNG" alt="ELF" style="zoom: 80%;" />

内存分区

<img src="images\virtual-memory.PNG" alt="virtual-memory" style="zoom:67%;" />

```c++
#include <iostream>
using namespace std;
/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/
int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```



### 堆与栈 

https://sourceware.org/gdb/download/onlinedocs/gdb.pdf

<img src="images\stack.PNG" alt="stack" style="zoom:38%;" />

栈溢出: 一般情况操作系统为每个进程会固定栈空间的大小

```c++
$ ulimit -s 
8192
```

如果出现两个函数互相调用或者递归无退出条件时，栈空间的就会无限增长。栈一般分为内核栈与用户栈，在栈顶会有一个特殊的内存页 guard，当栈一旦越界访问该特殊的 guard 页时，则会出现栈溢出的错误。

堆：
堆的内存空间一般由操作系统或者专门内存程序来管理的。在 C/C++ 一般用 malloc 或者 new 来从堆中申请内存，使用 free 或者 delete 来释放空间，空间释放后会有操作系统进行回收。

**堆与栈的优缺点：**

1. 申请方式：栈中存放的变量在编译时由**编译器**为其在栈上分配了空间，即程序编译后该变量在栈中使用的内存即确定，释放时也由于函数调用的返回，栈的空间会自动进行回收。堆中存放的变量由**程序运行时**决定的，会有操作系统或者内存管理模块来进行分配的。
2. 申请后系统响应：分配栈空间时如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出，绝大多数情况下，栈的空间较小，一般栈上分配的变量不会占用太大的空间，且当函数返回时，当前栈帧中的变量生存周期会结束；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上，堆上可以分配较大的空间，如果不对申请的内存进行释放，则堆上存储的变量生存周期一直存在，直到当前进程退出。
   栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，且只能被当前的线程访问；堆在内存中的空间（向高地址扩展）是不连续的，中间允许有间隔，**堆中的内存并不是线程安全的**，同一进程的线程都都可访问。
3. 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。

存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

**两级内存管理：**
操作系统按照段页式来管理内存，当需要创建新的进程或者线程时，操作系统会为新创建的进程分配物理页，当运行的进程需要更多的内存时，操作系统也会为其分配新的物理页并将其映射到该进程的虚拟地址空间中。
程序运行时，每个程序都含有一个内存管理的子程序，专门负责程序中的内存申请和释放。



### 变量定义与生命周期

作用域：全局，局部，语句，类，命名空间，文件作用域。

**全局变量：**在一个源文件中定义，就可以作用于所有的源文件。其他源文件需要用 extern 关键字声明。

**静态全局变量：**具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

**局部变量：**具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回，局部变量对于函数外部的程序来说是不可见的。当然内部实际更复杂，实际是以 {} 为作用域的。

**静态局部变量：**具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见, 只有定义该变量的函数内部可以使用访问和修改该变量。



生命周期：

全局变量：整个程序运行期间都会一直存在，都可以随时访问，当**程序结束**时，对应的变量则会自动销毁，内存会被系统回收。

局部变量：仅限于函数被调用期间，当**函数调用结束**时，该变量会自动销毁。

静态局部变量：静态局部变量的作用域仅限于函数内部，它的作用域与局部变量相同，但实际上该变量在程序运行期间是一直存在的，生命周期贯穿于整个**程序运行**期间。**局部静态变量只能被初始化一次。**



从分配内存空间看：不同生命周期的变量，在程序内存中的分布位置是不一样的。我们知道程序的内存分为代码区（.text）、全局数据区（.data，.bss，.rodata）、堆区（heap）、栈区（stack），不同的内存区域，对应不同的生命周期。

静态变量一般存储在数据段，包括 data 段、bss 段、rodata 段，其中 data 存储已经已经初始化的静态变量和全局变量，bss 存储未初始化的静态变量与全局变量。这里静态变量包括全局变量，静态全局变量，静态局部变量。
局部变量一般存储在栈区或者堆区。

静态变量和栈变量、堆变量的区别：静态变量会被放在程序的静态数据存储区（.data 段，.bss 段，.rodata 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。

静态变量和全局变量的区别：静态变量仅在变量的作用范围内可见，实际是依靠编译器来控制作用域。全局变量在整个程序范围内都可见。

全局变量定义在不要在头文件中定义：如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为重复定义而报错。**一般情况下我们将变量的定义放在 .cpp 文件中，一般在 .h 文件使用extern 对变量进行声明。**



### 内存对齐

内存对齐使得程序便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；另一方面提高内存的访问效率，因为 CPU 在读取内存时，是以块为单位进行读取。

```c++
/*
 说明：程序是在 64 位编译器下测试的
 */
 #include <iostream>
 using namespace std;
 #define offset(TYPE,MEMBER) ((long long)&((TYPE *)0)->MEMBER)//这里得改 long long

 struct A
 {
     short var; // 偏移 0 字节 （内存对齐原则 : short 2 字节 + 填充 2 个字节）
     int var1;  // 偏移 4 字节 （内存对齐原则：int 占用 4 个字节）
     long var2; // 偏移 8 字节 （内存对齐原则：long 占用 8 个字节）
     char var3; // 偏移 16 字节 （内存对齐原则：char 占用 1 个字节 + 填充 7 个字节）
     string s;  // 偏移 24 字节 （string对象的大小依赖于实现。std::string通常包含一个指针、一个长度值和一个容量值，其大小因编译器和库的实现而异。在64位系统上，std::string可能占用24字节）
 };
```

结构体中的 static 成员变量不占用结构体的空间，由于静态成员变量在程序初始化时已经在静态存储区分配完成，所有该结构体实例中的静态成员都指向同一个内存区域

```c++
struct st {
    char a;
    int b;
    static double c; //静态成员
} T;
cout<<sizeof(st)<<endl;
// 8
```

指定以1字节对齐

```c++
#pragma pack(push)
#pragma pack(1)
struct A
{...
};
#pragma pack(pop)
```

**alignof**: `C++ 11` 以后新增 `alignof` 的特性，通过调用 `alignof` 返回当前变量的字节对齐方式。

