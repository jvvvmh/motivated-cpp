# Motivated C++

[TOC]

## C++编译与语言相关

### C++内存管理

ELF: Executable and Linkable Format

<img src="images\ELF.PNG" alt="ELF" style="zoom: 80%;" />

内存分区

<img src="images\virtual-memory.PNG" alt="virtual-memory" style="zoom:67%;" />

```c++
#include <iostream>
using namespace std;
/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/
int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```



### 堆与栈 

https://sourceware.org/gdb/download/onlinedocs/gdb.pdf

<img src="images\stack.PNG" alt="stack" style="zoom:38%;" />

栈溢出:
一般情况操作系统为每个进程会固定栈空间的大小：

```c++
$ ulimit -s 
8192
```

如果出现两个函数互相调用或者递归无退出条件时，栈空间的就会无限增长。栈一般分为内核栈与用户栈，在栈顶会有一个特殊的内存页 guard，当栈一旦越界访问该特殊的 guard 页时，则会出现栈溢出的错误。

堆：
堆的内存空间一般由操作系统或者专门内存程序来管理的。在 C/C++ 一般用 malloc 或者 new 来从堆中申请内存，使用 free 或者 delete 来释放空间，空间释放后会有操作系统进行回收。

**堆与栈的优缺点：**

1. 申请方式：栈中存放的变量在编译时由**编译器**为其在栈上分配了空间，即程序编译后该变量在栈中使用的内存即确定，释放时也由于函数调用的返回，栈的空间会自动进行回收。堆中存放的变量由**程序运行时**决定的，会有操作系统或者内存管理模块来进行分配的。
2. 申请后系统响应：分配栈空间时如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出，绝大多数情况下，栈的空间较小，一般栈上分配的变量不会占用太大的空间，且当函数返回时，当前栈帧中的变量生存周期会结束；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上，堆上可以分配较大的空间，如果不对申请的内存进行释放，则堆上存储的变量生存周期一直存在，直到当前进程退出。
   栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，且只能被当前的线程访问；堆在内存中的空间（向高地址扩展）是不连续的，中间允许有间隔，**堆中的内存并不是线程安全的**，同一进程的线程都都可访问。
3. 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。

存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

**两级内存管理：**
操作系统按照段页式来管理内存，当需要创建新的进程或者线程时，操作系统会为新创建的进程分配物理页，当运行的进程需要更多的内存时，操作系统也会为其分配新的物理页并将其映射到该进程的虚拟地址空间中。
程序运行时，每个程序都含有一个内存管理的子程序，专门负责程序中的内存申请和释放。











